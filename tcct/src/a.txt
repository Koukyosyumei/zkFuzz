body: Block { statements: [
    
InitializationBlock { initializations: [] }, 
InitializationBlock { initializations: [] }, 
InitializationBlock { initializations: [Declaration { name: "in", dimensions: [], is_constant: true }] }, 
InitializationBlock { initializations: [Declaration { name: "out", dimensions: [], is_constant: true }] }, 
InitializationBlock { initializations: [Declaration { name: "inv", dimensions: [], is_constant: true }] }, 
 
Substitution { variable: "inv", access: [], 
 　　　　　　　　　operation: AssignSignal, 
 　　　　　　　　　rhe: InlineSwitchOp { cond: InfixOp 
 　　　　　　　　　　　　　　　　　　　　　{ lhe: Variable { name: "in", access: [] }, 
 　　　　　　　　　　　　　　　　　　　　　　infix_op: NotEq, rhe: Number { value: BigInt { sign: NoSign, data: BigUint { data: [] } } } }, 
 　　　　　　　　　　　　　　　　　　　　　if_true: InfixOp { lhe: Number { value: BigInt { sign: Plus, data: BigUint { data: [1] } } }, infix_op: Div, rhe: Variable { name: "in", access: [] } }, 
 　　　　　　　　　　　　　　　　　　　　　if_false: Number { value: BigInt { sign: NoSign, data: BigUint { data: [] } } } } }, 
Substitution { variable: "out", access: [], 
                　operation: AssignConstraintSignal, 
                　rhe: InfixOp { lhe: InfixOp { lhe: PrefixOp { prefix_op: Sub, rhe: Variable { name: "in", access: [] } }, infix_op: Mul, rhe: Variable { name: "inv", access: [] } }, infix_op: Add, rhe: Number { value: BigInt { sign: Plus, data: BigUint { data: [1] } } } } }, 
ConstraintEquality { lhs_expression: InfixOp { lhe: Variable { name: "in", access: [] }, infix_op: Mul, rhe: Variable { name: "out", access: [] } }, rhs_expression: Number { value: BigInt { sign: NoSign, data: BigUint { data: [] } } } }] }